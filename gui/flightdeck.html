<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CHIMERA FLIGHT DECK</title>
<style>
body {
    background:#05070a;
    color:#cfd3dc;
    font-family: monospace;
    margin:0;
}
header {
    padding:8px;
    background:#0a0f14;
    border-bottom:1px solid #222;
}
h1 { color:#00bfff; margin:0; }
.grid {
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:8px;
    padding:8px;
}
.panel {
    background:#0a0f14;
    border:1px solid #222;
    padding:6px;
}
canvas {
    width:100%;
    height:200px;
    background:#05070a;
    border:1px solid #222;
}
table {
    width:100%;
    border-collapse:collapse;
    font-size:11px;
}
th, td {
    border:1px solid #222;
    padding:3px;
}
th { color:#00bfff; background:#0f141a; }
.good { color:#00ff9c; }
.bad { color:#ff4d4d; }
.warn { color:#ffd166; }
</style>
</head>
<body>

<header>
<h1>CHIMERA â€” TRADING FLIGHT DECK</h1>
</header>

<div class="grid">

<div class="panel">
<h3>Equity Curve (Session)</h3>
<canvas id="equity"></canvas>
</div>

<div class="panel">
<h3>Regime Timeline</h3>
<table id="regime">
<tr><th>Symbol</th><th>Regime</th><th>Conf</th></tr>
</table>
</div>

<div class="panel">
<h3>Edge Decay Monitor</h3>
<table id="edge">
<tr><th>Engine</th><th>Edge</th><th>Trend</th></tr>
</table>
</div>

<div class="panel">
<h3>Shadow vs Live Divergence</h3>
<table id="diverge">
<tr><th>Symbol</th><th>Shadow PnL</th><th>Live PnL</th><th>Gap</th></tr>
</table>
</div>

<div class="panel">
<h3>Orderbook Snapshot</h3>
<table id="book">
<tr><th>Side</th><th>Price</th><th>Size</th></tr>
</table>
</div>

<div class="panel">
<h3>ML Feature Stream</h3>
<table id="ml">
<tr><th>Feature</th><th>Value</th></tr>
</table>
</div>

<div class="panel">
<h3>Monte Carlo Risk Bands</h3>
<canvas id="mc"></canvas>
</div>

<div class="panel">
<h3>Live Trades</h3>
<table id="trades">
<tr><th>Time</th><th>Sym</th><th>Side</th><th>Qty</th><th>Px</th><th>PnL</th></tr>
</table>
</div>

<div class="panel">
<h3>Latency + OFI</h3>
<table id="lat">
<tr><th>Sym</th><th>ms</th><th>Spr</th><th>OFI</th></tr>
</table>
</div>

</div>

<script>
const eqCanvas = document.getElementById("equity");
const eqCtx = eqCanvas.getContext("2d");
const mcCanvas = document.getElementById("mc");
const mcCtx = mcCanvas.getContext("2d");

let equity = [];
let mcBands = [];

function drawCurve(ctx, data, color) {
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    if (data.length < 2) return;
    ctx.strokeStyle = color;
    ctx.beginPath();
    data.forEach((v,i)=>{
        const x = i*(ctx.canvas.width/(data.length-1));
        const y = ctx.canvas.height - ((v - Math.min(...data)) /
              (Math.max(...data)-Math.min(...data)+1e-6)) * ctx.canvas.height;
        if (i==0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
    });
    ctx.stroke();
}

async function refresh() {
    try {
        const res = await fetch("/api/snapshot");
        const data = await res.json();

        const tables = {
            REGIME: document.getElementById("regime"),
            EDGE: document.getElementById("edge"),
            DIVERGE: document.getElementById("diverge"),
            BOOK: document.getElementById("book"),
            ML: document.getElementById("ml"),
            TRADE: document.getElementById("trades"),
            LATENCY: document.getElementById("lat")
        };

        Object.values(tables).forEach(t=>{
            const h=t.rows[0].innerHTML;
            t.innerHTML="<tr>"+h+"</tr>";
        });

        data.slice(-400).forEach(e=>{
            if (e.type === "PNL") {
                equity.push(parseFloat(e.session || 0));
                if (equity.length > 200) equity.shift();
                drawCurve(eqCtx, equity, "#00ff9c");
            }

            if (e.type === "MC") {
                mcBands.push(parseFloat(e.band || 0));
                if (mcBands.length > 200) mcBands.shift();
                drawCurve(mcCtx, mcBands, "#ffd166");
            }

            const t = tables[e.type];
            if (!t) return;

            const r = t.insertRow();
            Object.keys(e).forEach(k=>{
                if (k === "type" || k === "ts") return;
                const c = r.insertCell();
                c.textContent = e[k];
            });
        });
    } catch {}
}

setInterval(refresh, 1000);
refresh();
</script>

</body>
</html>
