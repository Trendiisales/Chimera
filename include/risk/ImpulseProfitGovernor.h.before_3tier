#pragma once
#include <cstdint>
#include <algorithm>

struct ImpulseProfitGovernor {

    /* ===== CONSTANTS (FROM YOUR LIVE LOGS) ===== */
    const double IMPULSE_WEAK      = 0.18;
    const double IMPULSE_STRONG    = 0.35;

    const double HARD_STOP_XAU     = 2.20;
    const double TRAIL_ENABLE_XAU  = 1.40;
    const double TRAIL_OFFSET_XAU  = 0.85;

    const double ATR_MICRO_XAU     = 0.32;

    const uint64_t ENTRY_FREEZE_NS = 250'000'000; // 250ms
    const uint64_t COOLDOWN_NS     = 600'000'000; // 600ms

    /* ===== STATE ===== */
    uint64_t entry_freeze_until = 0;
    uint64_t cooldown_until = 0;

    bool trailing_enabled = false;
    double stop_price = 0.0;

    /* ===== ENTRY GATE (FIXED) ===== */
    bool allow_entry(double impulse, uint64_t now_ns) {
        // Hard cooldown check (after exits)
        if (now_ns < cooldown_until) {
            return false;
        }

        // If impulse is weak, set freeze and reject
        if (impulse < IMPULSE_WEAK) {
            entry_freeze_until = now_ns + ENTRY_FREEZE_NS;
            return false;
        }

        // âœ… FIX: If impulse is good, allow entry immediately
        // Don't check old freeze - good impulse overrides it
        return true;
    }

    /* ===== STOP INITIALIZATION ===== */
    void init_stop(double entry_price, bool is_long) {
        trailing_enabled = false;
        stop_price = is_long
            ? entry_price - HARD_STOP_XAU
            : entry_price + HARD_STOP_XAU;
    }

    /* ===== TRAIL ENABLE ===== */
    void maybe_enable_trailing(double favorable_move) {
        if (!trailing_enabled && favorable_move >= TRAIL_ENABLE_XAU) {
            trailing_enabled = true;
        }
    }

    /* ===== STOP UPDATE (CRITICAL LOGIC) ===== */
    void update_stop(
        double price,
        double adverse_move,
        bool is_long
    ) {
        if (!trailing_enabled) return;

        // ðŸš¨ KEY RULE: no tighten inside noise
        if (adverse_move < ATR_MICRO_XAU) return;

        double candidate = is_long
            ? price - TRAIL_OFFSET_XAU
            : price + TRAIL_OFFSET_XAU;

        if (is_long)
            stop_price = std::max(stop_price, candidate);
        else
            stop_price = std::min(stop_price, candidate);
    }

    /* ===== EXIT HANDLING ===== */
    void on_exit(uint64_t now_ns) {
        cooldown_until = now_ns + COOLDOWN_NS;
        trailing_enabled = false;
    }
};
