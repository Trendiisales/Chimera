#include "chimera/execution/BinanceIO.hpp"

#include <chrono>
#include <thread>
#include <sstream>
#include <iomanip>
#include <iostream>
#include <curl/curl.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>

namespace chimera {

static size_t curlWrite(void* contents, size_t size, size_t nmemb, void* userp) {
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

BinanceIO::BinanceIO(const BinanceConfig& cfg)
    : config(cfg), running(false) {}

BinanceIO::~BinanceIO() {
    disconnect();
}

void BinanceIO::connect() {
    running = true;
    ws_worker = std::thread(&BinanceIO::wsThread, this);
}

void BinanceIO::disconnect() {
    running = false;
    if (ws_worker.joinable()) {
        ws_worker.join();
    }
}

void BinanceIO::subscribeMarketData(
    const std::vector<std::string>& syms
) {
    std::lock_guard<std::mutex> lock(sym_mutex);
    symbols = syms;
}

uint64_t BinanceIO::nowMs() const {
    return std::chrono::duration_cast<
        std::chrono::milliseconds
    >(
        std::chrono::system_clock::now().time_since_epoch()
    ).count();
}

std::string BinanceIO::signQuery(const std::string& query) {
    unsigned char* digest;
    digest = HMAC(
        EVP_sha256(),
        config.api_secret.c_str(),
        config.api_secret.size(),
        (unsigned char*)query.c_str(),
        query.size(),
        NULL,
        NULL
    );

    std::ostringstream oss;
    for (int i = 0; i < 32; ++i) {
        oss << std::hex << std::setw(2) << std::setfill('0')
            << (int)digest[i];
    }
    return oss.str();
}

void BinanceIO::poll() {
    std::this_thread::sleep_for(
        std::chrono::milliseconds(10)
    );
}

void BinanceIO::sendOrder(const OrderRequest& req) {
    if (config.shadow_mode) {
        OrderUpdate up;
        up.client_id = req.client_id;
        up.exchange_id = "BINANCE-SHADOW-" + req.client_id;
        up.filled_qty = req.qty;
        up.avg_price = req.price;
        up.is_final = true;
        up.status = "FILLED";

        if (on_order_update) {
            on_order_update(up);
        }
        return;
    }

    restSendOrder(req);
}

void BinanceIO::cancelOrder(
    const std::string& client_id
) {
    if (config.shadow_mode) return;
    restCancelOrder(client_id);
}

void BinanceIO::restSendOrder(
    const OrderRequest& req
) {
    std::lock_guard<std::mutex> lock(rate_mutex);

    uint64_t now = nowMs();
    if (now - last_rest_ts < 100) {
        std::this_thread::sleep_for(
            std::chrono::milliseconds(100)
        );
    }
    last_rest_ts = now;

    std::ostringstream query;
    query << "symbol=" << req.symbol
          << "&side=" << (req.is_buy ? "BUY" : "SELL")
          << "&type=LIMIT"
          << "&timeInForce=GTC"
          << "&quantity=" << req.qty
          << "&price=" << req.price
          << "&newClientOrderId=" << req.client_id
          << "&timestamp=" << nowMs();

    std::string sig = signQuery(query.str());

    std::string url =
        config.rest_url +
        "/api/v3/order?" +
        query.str() +
        "&signature=" + sig;

    CURL* curl = curl_easy_init();
    if (!curl) return;

    std::string response;
    struct curl_slist* headers = NULL;
    std::string api_hdr = "X-MBX-APIKEY: " + config.api_key;
    headers = curl_slist_append(headers, api_hdr.c_str());

    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_POST, 1L);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curlWrite);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

    curl_easy_perform(curl);
    curl_easy_cleanup(curl);
}

void BinanceIO::restCancelOrder(
    const std::string& client_id
) {
    std::lock_guard<std::mutex> lock(rate_mutex);

    uint64_t now = nowMs();
    std::ostringstream query;
    query << "origClientOrderId=" << client_id
          << "&timestamp=" << now;

    std::string sig = signQuery(query.str());

    std::string url =
        config.rest_url +
        "/api/v3/order?" +
        query.str() +
        "&signature=" + sig;

    CURL* curl = curl_easy_init();
    if (!curl) return;

    struct curl_slist* headers = NULL;
    std::string api_hdr = "X-MBX-APIKEY: " + config.api_key;
    headers = curl_slist_append(headers, api_hdr.c_str());

    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "DELETE");
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_perform(curl);
    curl_easy_cleanup(curl);
}

void BinanceIO::wsThread() {
    while (running) {
        std::vector<std::string> local_syms;
        {
            std::lock_guard<std::mutex> lock(sym_mutex);
            local_syms = symbols;
        }

        for (const auto& sym : local_syms) {
            MarketTick t;
            t.symbol = sym;
            t.bid = 0.0;
            t.ask = 0.0;
            t.last = 0.0;
            t.bid_size = 0.0;
            t.ask_size = 0.0;
            t.ts_ns = nowMs() * 1000000ULL;

            if (on_tick) {
                on_tick(t);
            }
        }

        std::this_thread::sleep_for(
            std::chrono::milliseconds(50)
        );
    }
}

}
